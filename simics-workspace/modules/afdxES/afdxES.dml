// Copyright 2005-2011 Virtutech AB
dml 1.2;

device afdxES;

parameter desc = "afdx End System";
parameter documentation = "afdx End System";
parameter byte_order = "big-endian"; 
 
import "utility.dml";
import "io-memory.dml";
import "simics/devs/memory-space.dml";
import "packet-frame.dml";
import "config-tables.dml";
import "vl.dml";
import "constant.dml";
import "unpacket_frame.dml";
import "afdx-exchange.dml";
import "pci-action.dml";
import "pci-register.dml";
import "change_endian.dml";
import "tomiddleware.dml";
import "rm-handler.dml";

connect phyA {
	parameter documentation = "Send data to the second ARINC664 card";
    parameter configuration = "optional";

    interface ieee_802_3_mac {
        parameter c_type = "ieee_802_3_mac_interface_t";
    }
}

connect phyB {
	parameter documentation = "Send data to the second ARINC664 card";
    parameter configuration = "optional";

    interface ieee_802_3_mac {
        parameter c_type = "ieee_802_3_mac_interface_t";
    }
}


implement ieee_802_3_mac {
	method send_frame(uint8 *data, uint32 size) {
        local rm_cfg_cam item;
        local uint8 rm_index;
		local bool is_crc_ok;
        local RM_INFO rm_info;

        if (is_ieee_802_3_log_on) {
            call $print_ieee_802_3_mac_begin();
        }
	    call $recv_crc_check(data,size,$Table)->(is_crc_ok);
       
		if (is_crc_ok == false) {
			log "info":"crc check failed";
            return;
		} else {
            if (is_ieee_802_3_log_on) {
                call $print_ieee_802_3_mac_crc();
            }
        }
		
		call $change_endian(data, size);

        item.VL_ID = data[4];
        call $BinarySearchRMCfgCamArray($rm_cfg_cam_array, item) -> (rm_index);
        if (rm_index == -1) {
            log "error" : "Can't find this conf in current rm cfg cam table, please check!";
        } else {
            rm_index = $rm_cfg_cam_array[rm_index].address;
        }
        
        call $Init_RM_INFO(&rm_info, rm_index, size);

		local uint8 interface_id = data[11] >> 5;
        local uint8 frame_sn = data[size-5];
        local bool is_rm_ok;
        
        call $RM_Handler(&rm_info, interface_id, frame_sn) -> (is_rm_ok);
        if (is_rm_ok) {
            if (is_ieee_802_3_log_on) {
                call $print_ieee_802_3_mac_rm();
            }
            call $unpacket_frame(data, size)->($rx_mib);
        } else {
			log "error" : "Send from unkown network";
        }
	}
}

attribute middleware_mode "Used to switch middleware mode" { 
    parameter documentation = "Used to switch work mode (to664middleware/to429middleware)";
    parameter allocate_type = "uint32";
}

attribute is_cfg_done "If true, don't change cfg table index and write cfg table again!" {
    parameter allocate_type = "bool";
}

// USER-TODO: Add init() and post_init() methods here, if needed.
// init() will be run to set the empty state of the model, before any
// configuration or checkpointed attributes are set.  post_init() is run after
// all configuration attributes have been set.  This happens both when the
// initial configuration is set and when the configuration is loaded from a
// checkpoint.

method post_init() {
    call $pci_config.update_all_mappings();   
	call $gen_normal_table($Table);
    call $init_port_queue();
    call $init_middleware_mode();
    call $init_udp_flag();
    call $init_vl_cfg();
}
