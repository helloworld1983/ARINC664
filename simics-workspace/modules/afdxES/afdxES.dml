// Copyright 2005-2011 Virtutech AB
dml 1.2;

device afdxES;

parameter desc = "afdx End System";
parameter documentation = "afdx End System";
parameter byte_order = "big-endian"; 
 
import "utility.dml";
import "io-memory.dml";
import "simics/devs/memory-space.dml";
import "packet-frame.dml";
import "config-tables.dml";
import "vl.dml";
import "constant.dml";
import "unpacket_frame.dml";
import "afdx-exchange.dml";
import "pci-action.dml";
import "pci-register.dml";
import "change_endian.dml";

extern int socket_init(void);
extern int socket_recv(char *recvbuf, int size);
extern int socket_send(char *sendbuf, int size);

connect phyA {
	parameter documentation = "Send data to ARINC664 2";
    parameter configuration = "optional";
    interface data_exchange	{
        parameter c_type = "data_exchange_interface_t";
    }
}

connect phyB {
	parameter documentation = "Send data to ARINC664 2";
    parameter configuration = "optional";
    interface data_exchange	{
        parameter c_type = "data_exchange_interface_t";
    }
}

implement data_exchange {
	method send_frame(uint8 *data, uint32 size) {
        local rm_cfg_cam item;
        item.VL_ID = data[4];
        local uint8 position;
		local bool crc;
		local RX_MIB rx_mib_temp;

	    call $recv_crc_check(data,size,$Table)->(crc);
       
		if(crc == false) {
			log "info":"crc check failed";
            return;
		}
		
		call $change_endian(data,size);

        log "info" : "The $rm_cfg_cam_index = %d", $rm_cfg_cam_index;

        call $BinarySearchRMCfgCamArray($rm_cfg_cam_array, item) -> (position);
        position = $rm_cfg_cam_array[position].address;
        
        log "info" : "The position is %d", position;
        
        local uint8 VL_ENABLE = $rm_cfg_ram_array[position].ram_data.VL_ENABLE;
        local uint8 RM_ENABLE = $rm_cfg_ram_array[position].ram_data.RM_ENABLE;
        local uint8 NETWORK_A_IC_ENABLE = $rm_cfg_ram_array[position].ram_data.NETWORK_A_IC_ENABLE;
        local uint8 NETWORK_B_IC_ENABLE = $rm_cfg_ram_array[position].ram_data.NETWORK_B_IC_ENABLE;
        local uint8 NETWORK_A_ENABLE = $rm_cfg_ram_array[position].ram_data.NETWORK_A_ENABLE;
        local uint8 NETWORK_B_ENABLE = $rm_cfg_ram_array[position].ram_data.NETWORK_B_ENABLE;        
        local uint8 A_Interface_ID;
        local uint8 B_Interface_ID;
       
	   
        if (VL_ENABLE == 0) {
            return;
        }
       
        local uint8 frame_sn = data[size-5];
		local uint8 interface_id;
		interface_id = data[11]>>5;
		log "info" : "interace_ido = %d", interface_id;

        if (NETWORK_A_ENABLE == 1) {
            A_Interface_ID = 1;
        } else {
            A_Interface_ID = 0;
        }

        if (NETWORK_B_ENABLE == 1) {
            B_Interface_ID = 2;
        } else {
            B_Interface_ID = 0;
        }
		
		//for mib
		if((interface_id ==1) && (A_Interface_ID ==0))
			$rx_mib.disable_A_filt_count++;
		if((interface_id ==2) && (B_Interface_ID ==0))
			$rx_mib.disable_B_filt_count++;
        
	
        if ((frame_sn == $recv_vl[position].expect_sn) && ((interface_id == A_Interface_ID) || (interface_id == B_Interface_ID))) {
			$rx_mib.size = size;
            call $unpacket_frame(data, size)->($rx_mib);
            $recv_vl[position].expect_sn++;
            $recv_vl[position].expect_sn %= 256;
			if(interface_id == A_Interface_ID) call $mib_in_sum(&($maca_mib),size);
			else if(interface_id == B_Interface_ID) call $mib_in_sum(&($macb_mib),size);
        } else {
			log "info" : "Send from error network";
            return;
        }
	}
}

connect config_mac_mode {
    interface config_mac_mode {
        parameter c_type = "config_mac_mode_interface_t";
    }
}

attribute middleware_mode "Used to switch middleware mode" { 
    parameter documentation = "Used to switch work mode (to664middleware/to429middleware)";
    parameter allocate_type = "uint32";
}

attribute is_cfg_done "If true, don't change cfg table index and write cfg table again!" {
    parameter allocate_type = "bool";
}

method socket_loop_recv() {
    local int length;
    local uint8 *buf = new uint8 [PORT_DATA_SIZE];
    length = socket_recv(buf, PORT_DATA_SIZE);
    
    if (length > 0) {

    }
    after (1) call $socket_loop_recv();
    
}

method init_port_queue() {
    local uint32 i = 0;
    for (; i < PORT_SIZE; ++i) {
        call $InitPortQueue() -> ($port[i].queue);
    }    
}

method init_middleware_mode() {
    if ($middleware_mode == To664Middleware) {
        socket_init();
        call $socket_loop_recv();
    }    
}

method init_vl_cfg() {
    local uint32 i = 0;
    for (; i < SEND_VL_NUM; ++i) {
        $vl_index_array[i] = new uint8;
    }
    for (i = 0; i < RECV_VL_NUM; ++i) {
        $recv_vl[i].expect_sn = 0;
    }    
}

method cfg_table_index {
    $analyse_cfg_cam_index = 0;
    $analyse_cfg_ram_index = 0;
    $transmit_cfg_ram_index = 0;
    $scheduling_cfg_ram_index = 0;
    $rm_cfg_cam_indexq = 0;
    $rm_cfg_ram_index = 0;
    $fragment_cfg_ram_index = 0;
    $is_cfg_done = false;
}

// USER-TODO: Add init() and post_init() methods here, if needed.
// init() will be run to set the empty state of the model, before any
// configuration or checkpointed attributes are set.  post_init() is run after
// all configuration attributes have been set.  This happens both when the
// initial configuration is set and when the configuration is loaded from a
// checkpoint.

method post_init() {
    call $pci_config.update_all_mappings();   
	call $gen_normal_table($Table);
    memset($udp_first,1,PORT_SIZE);
    call $init_port_queue();
    call $init_middleware_mode();
    call $init_vl_cfg();
	
	$phy_max_bandwidth = 200;
}
