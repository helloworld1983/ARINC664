// Copyright 2005-2011 Virtutech AB
dml 1.2;

device afdxES;

parameter desc = "afdx End System";
parameter documentation = "afdx End System";
parameter byte_order = "big-endian"; 
 
import "utility.dml";
import "io-memory.dml";
import "simics/devs/memory-space.dml";
import "packet-frame.dml";
import "config-tables.dml";
import "vl.dml";
import "constant.dml";
import "unpacket_frame.dml";
import "afdx-exchange.dml";
import "pci-action.dml";
import "pci-register.dml";
import "change_endian.dml";

extern int socket_init(void);
extern int socket_recv(char *recvbuf, int size);
extern int socket_send(char *sendbuf, int size);

connect local_space {
    parameter documentation = "The local-space the device uses to send/receive"
        + "data to/from PCI memory space.";
    parameter configuration = "optional";
    interface memory_space 
	{
        parameter c_type = "memory_space_interface_t";
    }
}

connect phyA {
	parameter documentation = "Send data to ARINC664 2";
    parameter configuration = "optional";
    interface data_exchange 
	{
        parameter c_type = "data_exchange_interface_t";
    }
}

connect phyB {
	parameter documentation = "Send data to ARINC664 2";
    parameter configuration = "optional";
    interface data_exchange	{
        parameter c_type = "data_exchange_interface_t";
    }
}

implement data_exchange {
	method send_frame(uint8 *data, uint32 size) {
        log "info" : "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ called by nic2  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@";
        local rm_cfg_cam item;
        item.VL_ID = data[4];
        local uint8 position;
		local bool crc;
		local RX_MIB rx_mib_temp;

        log "info" : "The size is %d", size;
      

       
	    call $recv_crc_check(data,size,$Table)->(crc);
       
		if(crc == false) 
		{
			log "info":"crc check failed";
            return ;
		}
		
		call $change_endian(data,size);
        //crc check


        log "info" : "The $rm_cfg_cam_index = %d", $rm_cfg_cam_index;

        call $BinarySearchRMCfgCamArray($rm_cfg_cam_array, item) -> (position);
        position = $rm_cfg_cam_array[position].address;
        
        log "info" : "The position is %d", position;
        
        local uint8 VL_ENABLE = $rm_cfg_ram_array[position].ram_data.VL_ENABLE;
        local uint8 RM_ENABLE = $rm_cfg_ram_array[position].ram_data.RM_ENABLE;
        local uint8 NETWORK_A_IC_ENABLE = $rm_cfg_ram_array[position].ram_data.NETWORK_A_IC_ENABLE;
        local uint8 NETWORK_B_IC_ENABLE = $rm_cfg_ram_array[position].ram_data.NETWORK_B_IC_ENABLE;
        local uint8 NETWORK_A_ENABLE = $rm_cfg_ram_array[position].ram_data.NETWORK_A_ENABLE;
        local uint8 NETWORK_B_ENABLE = $rm_cfg_ram_array[position].ram_data.NETWORK_B_ENABLE;        
        local uint8 A_Interface_ID;
        local uint8 B_Interface_ID;
       
	   
        if (VL_ENABLE == 0) {
            return;
        }
       
        local uint8 frame_sn = data[size-5];
		local uint8 interface_id;
		interface_id = data[11]>>5;
		log "info" : "interace_ido = %d", interface_id;

        if (NETWORK_A_ENABLE == 1) {
            A_Interface_ID = 1;
        } else {
            A_Interface_ID = 0;
        }

        if (NETWORK_B_ENABLE == 1) {
            B_Interface_ID = 2;
        } else {
            B_Interface_ID = 0;
        }
		
		//for mib
		if((interface_id ==1) && (A_Interface_ID ==0))
			$rx_mib.disable_A_filt_count++;
		if((interface_id ==2) && (B_Interface_ID ==0))
			$rx_mib.disable_B_filt_count++;
        
	
        if ((frame_sn == $recv_vl[position].expect_sn) && ((interface_id == A_Interface_ID) || (interface_id == B_Interface_ID))) {
			$rx_mib.size = size;
            call $unpacket_frame(data, size)->($rx_mib);
            $recv_vl[position].expect_sn++;
            $recv_vl[position].expect_sn %= 256;
			if(interface_id == A_Interface_ID) call $mib_in_sum(&($maca_mib),size);
			else if(interface_id == B_Interface_ID) call $mib_in_sum(&($macb_mib),size);
        } else {
			log "info" : "Send from error network";
            return;
        }
	}
}

connect config_mac_mode {
    interface config_mac_mode {
        parameter c_type = "config_mac_mode_interface_t";
    }
}

attribute mode "Used to switch work mode" { // 0 and 1
    parameter allocate_type = "uint32";
}

method socket_loop_recv() {
    local int length;
    local uint8 *buf = new uint8 [PORT_DATA_SIZE];
    length = socket_recv(buf, PORT_DATA_SIZE);
    
    if (length > 0) {

    }
    after (1) call $socket_loop_recv();
    
}

// USER-TODO: Add init() and post_init() methods here, if needed.
// init() will be run to set the empty state of the model, before any
// configuration or checkpointed attributes are set.  post_init() is run after
// all configuration attributes have been set.  This happens both when the
// initial configuration is set and when the configuration is loaded from a
// checkpoint.


method post_init() 
{
    call $pci_config.update_all_mappings();   //测试需要，暂时先注释掉
	call $gen_normal_table($Table);
    memset($udp_first,1,PORT_SIZE);
    local uint32 i = 0;
    for (; i < PORT_SIZE; ++i) {
        call $InitPortQueue() -> ($port[i].queue);
    }
    if ($mode == 1) {
        socket_init();
        call $socket_loop_recv();
    }
    local uint32 j = 0;
    for (; j < SEND_VL_NUM; ++j) {
        $vl_index_array[j] = new uint8;
    }
    local uint32 k = 0;
    for (; k < RECV_VL_NUM; ++k) {
        $recv_vl[k].expect_sn = 0;
    }
	
	$phy_max_bandwidth = 200;
}
