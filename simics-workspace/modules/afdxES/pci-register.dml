dml 1.2;

import "pci-device.dml";          // Generic PCI device
import "binary-search.dml";
import "quick-sort.dml";
import "log.dml";

// Basic bank declaration
bank pci_config {
    // List of base address registers used by the device
    parameter base_address_registers = ["base_address_0", "base_address_2"];

    // This device can perform PCI DMA accesses
    parameter busmaster = true;

    register vendor_id { parameter hard_reset_value = 0x8620; } // Hwacreate
    register device_id { parameter hard_reset_value = 0x0001; } //afdx 001

    
    register revision_id { parameter value = 0x00; }
    register class_code { parameter value = 0x5; }
    
    register base_address_0 @ 0x10 is (io_base_address) {       
        parameter size_bits = 0x8;
        parameter map_func = 0;
    }
    register base_address_1 @ 0x14 is (no_base_address);
    register base_address_2 @ 0x18 is (memory_base_address) {       
        parameter size_bits = 0x16;
        parameter map_func = 1;
    }
    register base_address_3 @ 0x1C is (no_base_address);
    register base_address_4 @ 0x20 is (no_base_address);
    register base_address_5 @ 0x24 is (no_base_address);
    
    register subsystem_vendor_id {
        parameter value = 0x1415;
    }
    register subsystem_id {
        parameter value = 0x2360;
    }

    // Set correct size, but we don't model it, so do not set it as enabled
    register expansion_rom_base {
        parameter size_bits = 18;
    }

    register interrupt_pin {
        parameter hard_reset_value = 0x1;
    }    
}

data uint32 count;

bank pci9056{
    parameter documentation = "Control and Status Register Mapping";
    parameter function = 0;
    parameter byte_order = "little-endian";       
    parameter register_size = 4;
    parameter partial = true;                     

    register lmisc1 @ 0x000d "Local Miscellaneous Control" {
        parameter hard_reset_value = 0x4;
    }

    register intcsr @ 0x0068 "Interrupt Control/Status" {
        field ie [8:8] "PCI Interrupt Enable";
        field liie [11:11] "Local Interrupt Input Enable";
        field lioe [16:16] "Local Interrupt Output Enable";
        field dma0ie [18:18] "DMA Channel 0 Interrupt Enable";
        field dma1ie [19:19] "DMA Channel 1 Interrupt Enable";
    }

    register cntrl @ 0x006c "Serial EEPROM Control, PCI Command Codes,User I/O Control, and Init Control" {
        field prccd [3:0] "PCI Read Command Code for DMA";
        field pwccd [7:4] "PCI Write Command Code for DMA";
        field pmrcc [11:8] "PCI Memory Read Command Code for Direct Master";
        field pmwcc [15:12] "PCI Memory Write Command Code for Direct Master";
        field gpo [16:16] "General-Purpose Output";
        field gpi [17:17] "General-Purpose Input";
        field uilp [18:18] "USERi or LLOCKi# Pin Select";
        field uolp [19:19] "USERo or LLOCKo# Pin Select";
    }

    register dmamode0 @ 0x0080 "DMA Channel 0 Mode" {
        field lbw [1:0] "DMA Channel 0 Local Bus Data Width";
        field tarie [6:6] "DMA Channel 0 TA#/READY# Input Enable";
        field bie [7:7] "DMA Channel 0 Continuous Burst Enable";
        field lbe [8:8] "DMA Channel 0 Local Burst Enable";
        field die [10:10] "DMA Channel 0 Done Interrupt Enable";
    }

    register dmapadr0 @ 0x0084 "DMA Channel 0 PCI Address" {
        field padr0 [31:0] "DMA Channel 0 PCI Address";
    }

    register dmaladr0 @ 0x0088 "DMA Channel 0 Local Address" {
        field ladr0 [31:0] "DMA Channel 0 Local Address";
    }

    register dmasiz0 @ 0x008c "DMA Channel 0 Transfer Size" {
        field siz0 [22:0] "DMA Channel 0 Transfer Size (Bytes)";
        method after_write(memop) {
            // after read 0x3020, == rx_frame_len;
        }
    }

    register dmadpr0 @ 0x0090 "DMA Channel 0 Descriptor Pointer" {
        field dmad0 [3:3] "DMA Channel 0 Direction of Transfer";
    }

    register dmamode1 @ 0x0094 "DMA Channel 1 Mode" {
        field lbw [1:0] "DMA Channel 1 Local Bus Data Width";
        field tarie [6:6] "DMA Channel 1 TA#/READY# Input Enable";
        field bie [7:7] "DMA Channel 1 Continuous Burst Enable";
        field lbe [8:8] "DMA Channel 1 Local Burst Enable";
        field die [10:10] "DMA Channel 1 Done Interrupt Enable";
    }

    register dmapadr1 @ 0x0098 "DMA Channel 1 PCI Address" {
        field padr1 [31:0] "DMA Channel 1 PCI Address";
    }

    register dmaladr1 @ 0x009c "DMA Channel 1 Local Address" {
        field ladr1 [31:0] "DMA Channel 1 Local Address";
    }

    register dmasiz1 @ 0x00a0 "DMA Channel 1 Transfer Size" {
        field siz1 [22:0] "DMA Channel 1 Transfer Size (Bytes)";
    }

    register dmadpr1 @ 0x00a4 "DMA Channel 1 Descriptor Pointer" {
        field dmad1 [3:3] "DMA Channel 0 Direction of Transfer";
    }

    register dmacsr0 size 1 @ 0x00a8 "DMA Channel 0 Command/Status" {
        field dma0e [0:0] "DMA Channel 0 Enable";
        field dma0s [1:1] "DMA Channel 0 Start" {
            method write(value) {
                if (value == 1) {
                    log "info",2,0: "DMA Channel 0 Start";
                    //ready to transmit data from local space to pci memory space
                    // call $receive();
                }
            }
        }
        field dma0a [2:2] "DMA Channel 0 Abort";
        field dma0c [3:3] "DMA Channel 0 Clear Interrupt" {
            method write(value) {
                if (value == 1) {
                    call $pci_config.pci_lower_interrupt();
                    $dmacsr0.dma0e = 0;
                    $dmacsr0.dma0s = 0;
                }
            }
        }
        field dma0d [4:4] is (read_only) "DMA Channel 0 Done" {
            parameter hard_reset_value = 0x1;
        }
        field res [7:5] is (reserved);
    }
    register dmacsr1 size 1 @ 0x00a9 "DMA Channel 1 Command/Status" {
        field dma1e [0:0] "DMA Channel 1 Enable";
        field dma1s [1:1] "DMA Channel 1 Start" {
            method write(value) {
                if (value == 1) {
                    log "info",2,0: "DMA Channel 0 Start";
                    //ready to transmit data from pci memory space to local space
                    call $transmit();
				    //call $cycle();
                }
            }
        }
        field dma1a [2:2] "DMA Channel 1 Abort";
        field dma1c [3:3] "DMA Channel 1 Clear Interrupt" {
            method write(value) {
                if (value == 1) {
                    //lower pci interrupt
                    call $pci_config.pci_lower_interrupt();
                    $dmacsr1.dma1e = 0;
                    $dmacsr1.dma1s = 0;
                }
            }
        }
        field dma1d [4:4] is (read_only) "DMA Channel 1 Done" {
            parameter hard_reset_value = 0x1;
        }
        field res [7:5] is (reserved);
    }
    register loopdmadone size 4 @0x00ac "DMA done";
	register recvdmadone size 4 @0x00b0 "receive DMA done";
}


//for test start
data uint32 rm_num;
//for test end

bank pciport{
    parameter documentation = "Control and Status Register Mapping";
    parameter function = 1;
    parameter byte_order = "big-endian";
    parameter register_size = 4;
    parameter partial = true;

    register device_soft_reset @ 0x0000 "reset"{
        field swr [0:0] "Device Software Reset"{
            parameter hard_reset_value = 0x0;
            method write(value) {
                if (value == 1)
                    log "info",2,0: "device software reset";
            }
        }
        field res [31:1] is (reserved);
    }

    register device_version @ 0x0004 "version"{
        field dver [31:0] "Device Version"{
            parameter hard_reset_value = 0x0200;
            method read() -> (value){
                log "info",2,0: "device version is %d", $device_version.dver;
            }
        }
    }

    register device_state @ 0x0008 "device_state"{
        method read() -> (value) {
            value = 0x1;
        }
    }

    register work_mode @ 0x000C "work_mode"{
        field wmo [1:0] "Work Mode"{
            parameter hard_reset_value = 0x00;
            method write(value) {
                if (value == 0)
                    log "info",2,0: "normal work mode";
            }
        }
        field res [31:2] is (reserved);
    }

    register mac_mode @ 0x0010 "mac_mode"{
        field bmmo [0:0] "B Mac Mode"{
            method write(value) {
                if (value == 0) {
                    log "info",2,0: "B mac mode is 100Mbps";
                    $phy_max_bandwidth = 1280 * 1024;                    
                } else if (value == 1) {
                    $phy_max_bandwidth = 128 * 1024;
                    log "info",2,0: "B mac mode is 10Mbps";
                }
                $phyB.ieee_802_3_mac.config_bandwidth($phy_max_bandwidth);
            }
        }
        field ammo [1:1] "A Mac Mode"{
            method write(value) {
                if (value == 0) {
                    log "info",2,0: "A mac mode is 100Mbps";
                    $phy_max_bandwidth = 1280 * 1024;
                } else if (value == 1) {
                    log "info",2,0: "A mac mode is 10Mbps";
                    $phy_max_bandwidth = 128 * 1024;
                }
                $phyA.ieee_802_3_mac.config_bandwidth($phy_max_bandwidth);
            }
        }
        field res [31:2] is (reserved);
    }

    register host_time1 @ 0x0014 "host_time1"{
        field us [9:0] "us";
        field ms [19:10] "ms";
        field s [25:20] "s";
        field min [31:26] "min";
    }

    register host_time2 @ 0x0018 "host_time2"{
        field h [4:0] "hour";
        field day [13:5] "day";
        field res [31:14] is (reserved);
    }

    register flash_wr_data @ 0x001C "flash_wr_data"{
        field fwrd [15:0] "flash write data";
        field res [31:16] is (reserved);
    }

    register flash_wr_addr @ 0x0020 "flash_wr_addr"{
        field fwra [23:0] "flash write address";
        field res [31:24] is (reserved);
    }

    register flash_rd_addr @ 0x0024 "flash_rd_addr"{
        field frda [23:0] "flash read address";
        field res [31:24] is (reserved);
    }

    register flash_rd_rdy @ 0x0028 "flash_rd_rdy"{
        field rdr [0:0] "flash read ready";
        field res [31:1] is (reserved);
    }

    register flash_rd_data @ 0x002C "flash_rd_data"{
        field rdd [15:0] "flash read data";
        field res [31:16] is (reserved);
    }

    register phy_loc_sel @ 0x0030 "phy_loc_sel"{
        field pls [0:0] "phy location selected";
        field res [31:1] is (reserved);
    }

    register phy_wr_data @ 0x0034 "phy_wr_data"{
        field pwrd [15:0] "phy write data";
        field res [31:16] is (reserved);
    }

    register phy_wr_addr @ 0x0038 "phy_wr_addr"{
        field pad [4:0] "phy address";
        field pwra [9:5] "phy write address";
        field res [31:10] is (reserved);
    }

    register phy_rd_addr @ 0x003C "phy_rd_addr"{
        field pad [4:0] "phy address";
        field prda [9:5] "phy read address";
        field res [31:10] is (reserved);
    }

    register phy_rd_rdy @ 0x0040 "phy_rd_rdy"{
        field prdr [0:0] "phy read ready";
        field res [31:1] is (reserved);
    }

    register phy_rd_data @ 0x0044 "phy_rd_data"{
        field prdd [15:0] "phy read data";
        field res [31:16] is (reserved);
    }

    register IRIG_B_sat @ 0x0048 "IRIG_B_sat"{
        field irbs [0:0] "IRIG B sat"{
            method read() -> (value){
                if (value == 1)
                    log "info",2,0: "IRIG_B master";
                else if(value == 0)
                    log "info",2,0: "IRIG_B slave";
            }
        }
        field res [31:1] is (reserved);
    }

    register IRIG_B_set @ 0x004C "IRIG_B_set"{
        field irbse [0:0] "IRIG B set";
        field res [31:1] is (reserved);
    }

    register phy_check @ 0x0050 "phy_check"{
        field pch [0:0] "phy check";
        field res [31:1] is (reserved);
    }

    register secure_rd_addr @ 0x0054 "secure_rd_addr"{  
        field srda [7:0] "secure read address";
        field res [31:8] is (reserved);
    }

    register secure_rd_data @ 0x0058 "secure_rd_data"{
        field srdd [7:0] "secure read data";
        field res [31:8] is (reserved);
    }

    register secure_wr_addr @ 0x005C "secure_wr_addr"{
        field swra [7:0] "secure write address";
        field res [31:8] is (reserved);
    }

    register secure_wr_data @ 0x0060 "secure_wr_data"{
        field swrd [7:0] "secure write data";
        field res [31:8] is (reserved);
    }

    register reset_ctrl @ 0x0080 "reset_ctrl"{
        field amrct [0:0] "a mac reset control";
        field bmrct [1:1] "b mac reset control";
        field rmrct [2:2] "redundancy management reset control";
        field rxrct [3:3] "analyse receive reset control";
        field rirct [4:4] "receive IP recombination reset control";
        field tirct [5:5] "transmit IP fragmentation reset control";
        field txrct [6:6] "transmit reset control";
        field barct [7:7] "BAG reset control";
        field burct [8:8] "data buffer reset control";
        field pcrct [9:9] "PCI reset control";
        field tmrct [10:10] "time management reset control";
        field flrct [11:11] "flash reset control";
        field icrct [12:12] "ICMP server reset control";
        field res [31:13] is (reserved);
    }

    register loop_ctrl @ 0x0084 "loop_ctrl"{
        field amlct [0:0] "a mac loop control"{
            method write(value) {
                if (value == 1)
                    log "info",2,0: "enable a mac loop control";
                else if (value == 0)
                    log "info",2,0: "disable a mac loop control";
            }
        }
        field bmlct [1:1] "b mac loop control"{
            method write(value) {
                if (value == 1)
                    log "info",2,0: "enable b mac loop control";
                else if (value == 0)
                    log "info",2,0: "disable b mac loop control";
            }
        }
        field rmlct [2:2] "redundancy management loop control"{
            method write(value) {
                if (value == 1)
                    log "info",2,0: "enable redundancy management loop control";
                else if (value == 0)
                    log "info",2,0: "disable redundancy management loop control";
            }
        }
        field res [31:3] is (reserved);
    }
    
    register intr_set @ 0x2000 "intr_set"{
        field ints [0:0] "PCI interrupt set";
        field res [31:1] is (reserved);
    }

    register intr_clr @ 0x2004 "intr_clr"{
        field dintc [0:0] "PCI DMA interrupt clear"{
            method write(value) {
                if (value == 1)
                    log "info",2,0: "PCI DMA interrupt clear";
            }
        }
        field res1 [3:1] is (reserved);
        field rintc [4:4] "PCI receive interrupt clear"{
            method write(value) {
                if (value == 1)
                    log "info",2,0: "PCI receive interrupt clear";
            }
        }
        field res [31:5] is (reserved);
    }

    register intr_state @ 0x2008 "intr_state"{
        field ditr [0:0] "PCI DMA interrupt"{
            method read() -> (value) {
                if (value == 1)
                    log "info",2,0: "PCI interrupt caused by DMA done";
            }
        }
        field titr [1:1] "PCI test mode interrupt"{
            method read() -> (value) {
                if (value == 1)
                    log "info",2,0: "PCI interrupt caused by test mode";
            }
        }
        field mitr [2:2] "PCI monitor mode interrupt"{
            method read() -> (value) {
                if (value == 1)
                    log "info",2,0: "PCI interrupt caused by monitor mode";
            }
        }
        field reitr [3:3] "PCI interrupt register"{
            method read() -> (value) {
                if (value == 1)
                    log "info",2,0: "PCI interrupt caused by its register";
            }
        }
        field rxitr [4:4] "PCI receive interrupt"{
            method read() -> (value) {
                if (value == 1)
                    log "info",2,0: "PCI interrupt caused by received data frame";
            }
        }
        field res [31:5] is (reserved);
    }

    register intr_rx_port_id @ 0x200C "intr_rx_port_id"{
        field rxitr [6:0] "receive data frame PCI interrupt";
        field res [31:7] is (reserved);
    }

    register intr_en @ 0x2010 "intr_en"{
        field ints [0:0] "enable PCI interrupt";
        method write(value) {
            if (value == 1)
                log "info",2,0: "enable PCI interrupt";
        }
        field res [31:1] is (reserved);
    }

    register intr_rx_frame_en @ 0x2014 "intr_rx_frame_en"{
        field rxitr [0:0] "enable PCI receive interrupt"{
            method write(value) {
                if (value == 1)
                    log "info",2,0: "enable PCI receive interrupt";
            }
        }
        field res [31:1] is (reserved);
    }
    
    register cfg_table_src @ 0x1000 "cfg_table_src"	{
		parameter value = 0;
	}
	
	register cfg_done_host @ 0x1004 "cfg_done_host"	{
		method after_write(memop) {
            $is_cfg_done = true;
            call $Print_Cfg_Table();
            switch ($middleware_mode) {
            case To429Middleware:
                call $QuickSortAnalyseCamArray($analyse_cfg_cam_array);
                call $QuickSortRMCamArray($rm_cfg_cam_array);
                call $InitVLEnableInfo();
                break;
            case To664Middleware:
                call $LoadCfgTo664Middleware();
                break;
            default:
                log "error" : "Unsupported work mode!";
                break;
            }
        }
    }
	
    register cfg_done_615a @ 0x1008 "cfg_done_615a" {
        parameter value = 0;
		
    }
	
    register cfg_reset @ 0x1060 "cfg reset";
    register busy_reset_port @ 0x1064 "busy reset port";
    
    register analyse_cfg_cam_data1 @ 0x1010 "cam config data part1";
    register analyse_cfg_cam_data2 @ 0x1050 "cam config data part2";
    register analyse_cfg_cam_data3 @ 0x1054 "cam config data part3";
    register analyse_cfg_cam_addr  @ 0x100c "cam config address";
    register analyse_cfg_ram_data  @ 0x1018 "ram config data";
    register analyse_cfg_ram_addr  @ 0x1014 "ram config address";

    register transmit_cfg_ram_data1 @ 0x1020 "ram config data part1";
    register transmit_cfg_ram_data2 @ 0x1024 "ram config data part2";
    register transmit_cfg_ram_data3 @ 0x1028 "ram config data part3";
    register transmit_cfg_ram_data4 @ 0x1058 "ram config data part4";
    register transmit_cfg_ram_data5 @ 0x105c "ram config data part5";
    register transmit_cfg_ram_addr  @ 0x101c "ram config address";

    register scheduling_cfg_data @ 0x1030 "ram config data";
    register scheduling_cfg_addr @ 0x102c "ram config addr"; 

    register rm_cfg_cam_data @ 0x1038 "cam config data";
    register rm_cfg_cam_addr @ 0x1034 "cam config addr"; 

    register rm_cfg_ram_data @ 0x1040 "ram config data";
    register rm_cfg_ram_addr @ 0x103c "ram config addr"; 

    register fragment_cfg_data @ 0x1048 "ram config data";
    register fragment_cfg_addr @ 0x1044 "ram config addr"; 

    register icmp_serv_cfg_data @ 0x1074;
    register icmp_serv_cfg_addr @ 0x1070;
	
    register cfg_reset 
    {
        //field RETENTION [31:8] is (reserved);
        field reset     [7:7];
        field port_id   [6:0];
		
        method after_write(memop) {
            log "info"  ,2: "write cfg_reset";
            log "info"  ,2:"cfg_reset.port_id =%x",$this.port_id;
            log "info"  ,2:"cfg_reset.reset =%x",$this.reset;
        }
    }	
    register busy_reset_port 
    {
        field busy  [0:0];
        method after_write(memop) {
            log "info" ,2: "write busy_reset_port";
            log "info" ,2 :"busy_reset_port.busy = %x",$this.busy;
        }
    }
	
    register analyse_cfg_cam_data1  // -> [65:64]
    {  
        method after_write(memop) {
            log "info" ,2: "wirte analyse_cfg_cam_data1";
            log "info" ,2:"analyse_cfg_cam_data1=%x",$this;
        }
    }
	
    register analyse_cfg_cam_data2  // -> [65:64]
    {  
        method after_write(memop) {
            log "info",2 : "wirte analyse_cfg_cam_data2";
            log "info",2 : "analyse_cfg_cam_data2 = %x",$this;
        }
    }
	
    register analyse_cfg_cam_data3  // -> [65:64]
    {  
        //field RETENTION [31:2] is (reserved);
        field ICMP_TYPE_ID [1:1];
        field MULTICAST_ID [0:0];
		
        method after_write(memop) {
            log "info"  ,2: "wirte analyse_cfg_cam_data3";
            log "info" ,2:"analyse_cfg_cam_data3.ICMP_TYPE_ID = %x",$this.ICMP_TYPE_ID;
            log "info" ,2:"analyse_cfg_cam_data3.MULTICAST_ID = %x",$this.MULTICAST_ID;
        }
    }
	
    register analyse_cfg_ram_data 
    {
        // field RETENTION [31:4]is (zeros) "Reserved";
        field NETWORK_B_ENABLE [3:3] "NETWORK B ENABLE";
        field NETWORK_A_ENABLE [2:2] "NETWORK A ENABLE";
        field PORT_TYPE [1:0] "Port type";
		
        method after_write(memop) {
            log "info"  ,2: "write analyse_cfg_ram_data";
            log "info" ,2:"analyse_cfg_ram_data.PORT_TYPE = %x",$this.PORT_TYPE;
            log "info" ,2:"analyse_cfg_ram_data.NETWORK_A_ENABLE = %x",$this.NETWORK_A_ENABLE;
            log "info" ,2:"analyse_cfg_ram_data.NETWORK_B_ENABLE = %x",$this.NETWORK_B_ENABLE;
        }
    }	
	
    register transmit_cfg_ram_data1   // [31:0]
    {  
        field SOURCE_UDP_PORT_PART1 [31:18] "Source UDP Port Part1";
        field DEST_UDP_PORT [17:2] "Dest UDP Port";
        field SUB_VL_ID [1:0] "Sub VL ID";
		
        method after_write(memop) {
            log "info"  ,2: "write transmit_cfg_ram_data1";
            log "info" ,2:"transmit_cfg_ram_data1.SUB_VL_ID = %x",$this.SUB_VL_ID;
            log "info" ,2:"transmit_cfg_ram_data1.DEST_UDP_PORT = %x",$this.DEST_UDP_PORT;
            log "info" ,2:"transmit_cfg_ram_data1.SUB_VL_ID = %x",$this.SUB_VL_ID;
        }
    }

    register transmit_cfg_ram_data2   // [63:32]
    { 
        field USER_DEFINED_ID_PART1 [31:18] "User Defined ID Part1";
        field PROTOCAL_ID [17:10] "Protocal ID";
        field INTERFACE_ID [9:7] "Interface ID";
        field PARTITION_ID [6:2] "Partition ID";
        field SOURCE_UDP_PORT_PART2 [1:0] "Source UDP Port Part2";  
        method after_write(memop) {
            log "info" ,2: "write transmit_cfg_ram_data2";
            log "info" ,2:"transmit_cfg_ram_data2.USER_DEFINED_ID_PART1 = %x",$this.USER_DEFINED_ID_PART1;
            log "info" ,2:"transmit_cfg_ram_data2.PROTOCAL_ID = %x",$this.PROTOCAL_ID;
            log "info" ,2:"transmit_cfg_ram_data2.INTERFACE_ID= %x",$this.INTERFACE_ID;
            log "info" ,2:"transmit_cfg_ram_data2.PARTITION_ID= %x",$this.PARTITION_ID;
            log "info" ,2:"transmit_cfg_ram_data2.SOURCE_UDP_PORT_PART2= %x",$this.SOURCE_UDP_PORT_PART2;

        }
    }

    register transmit_cfg_ram_data3     // [95:64]
    { 
        field MIN_FRAME_LENGTH_PART1 [31:27] "Min Frame Length Part1";
        field IP_MULTICAST [26:26] "IP Multicast";
        field VL_INDEX [25:18] "VL Index";
        field VL_ID [17:2] "VL ID";
        field USER_DEFINED_ID_PART2 [1:0] "User Defined ID Part2";
		
        method after_write(memop) {
            log "info" ,2: "write transmit_cfg_ram_data3";
            log "info" ,2:"transmit_cfg_ram_data3.MIN_FRAME_LENGTH_PART1 = %x",$this.MIN_FRAME_LENGTH_PART1;
            log "info" ,2:"transmit_cfg_ram_data3.IP_MULTICAST = %x",$this.IP_MULTICAST;
            log "info" ,2:"transmit_cfg_ram_data3.VL_INDEX= %x",$this.VL_INDEX;
            log "info" ,2:"transmit_cfg_ram_data3.VL_ID = %x",$this.VL_ID;
            log "info" ,2:"transmit_cfg_ram_data3.USER_DEFINED_ID_PART2 = %x",$this.USER_DEFINED_ID_PART2;
        }
    }

    register transmit_cfg_ram_data4   // [109:66]
    { 
        //field RETENTION [31:8] is (reserved);
        field USER_DEFINED_ID_L[31:19] "User Defined ID Low";
        field PARTITION_ID [18:14] "Partition ID";
        field PORT_TYPE [7:6] "Port Type";
        field MIN_FRAME_LENGTH_PART2 [5:0] "Min Frame Length Part2"; 
		
        method after_write(memop) {
            log "info",2: "write transmit_cfg_ram_data4";
            log "info",2: "transmit_cfg_ram_data4.USER_DEFINED_ID_L = %x", $this.USER_DEFINED_ID_L;
            log "info",2: "transmit_cfg_ram_data4.PARTITION_ID = %x", $this.PARTITION_ID;
            log "info",2:"transmit_cfg_ram_data4.PORT_TYPE = %x",$this.PORT_TYPE;
            log "info",2:"transmit_cfg_ram_data4.MIN_FRAME_LENGTH_PART2 = %x",$this.MIN_FRAME_LENGTH_PART2;
        }
    }

    register transmit_cfg_ram_data5   // [138:110]
    { 
        //field RETENTION [31:8] is (reserved);
        field PRIVATE_IP [9:2] is (constant) {
            parameter hard_reset_value = 0xa;
        }
        field USER_DEFINED_ID_H [1:0] "User Defined ID High"; 
		
        method after_write(memop) {
            log "info",2: "write transmit_cfg_ram_data4";
            //log "info",2:"transmit_cfg_ram_data5.PRIVATE_IP = %x",$this.PRIVATE_IP;
            log "info",2:"transmit_cfg_ram_data5.USER_DEFINED_ID_H = %x",$this.USER_DEFINED_ID_H;
        }
    }
	
    register scheduling_cfg_data 
    {
        //field RETENTION [31:17] is (reserved);
        field BAG [16:0] "BAG";
		
        method after_write(memop){
            log "info",2: "write scheduling_cfg_data";
            log "info",2 :"scheduling_cfg_data.BAG = %x",$this.BAG;
        }
    }


    register rm_cfg_cam_data 
    {
        //field RETENTION [31:16] is (reserved);
        field VL_ID [15:0] "VL ID";
		
        method after_write(memop) {
            $rm_num++;
            log "info",2: "write rm_cfg_cam_data";
            log "info",2:"!!!!!!!!!!!%d rm_cfg_cam_data.VL_ID!!!!!!!!!!!!!!! = %x",$rm_num,$this.VL_ID;
        }
    }
	
    register rm_cfg_ram_data 
    {
        // field RETENTION [31:27] is (reserved);
        field VL_ENABLE [26:26] "VL Enable";
        field SKEW_MAX [25:5] "Skew max";
        field RM_ENABLE [4:4] "RM enable";
        field NETWORK_B_IC_ENABLE [3:3] "Network B IC Enable";
        field NETWORK_A_IC_ENABLE [2:2] "Network A IC Enable";
        field NETWORK_B_ENABLE [1:1] "Network B Enable";
        field NETWORK_A_ENABLE [0:0] "Network A Enable";
		
        method after_write(memop) {
            log "info" ,2: "write rm_cfg_ram_data";
            log "info" ,2:" rm_cfg_ram_data.VL_ENABLE = %x",$this.VL_ENABLE;
            log "info" ,2:" rm_cfg_ram_data.SKEW_MAX = %x",$this.SKEW_MAX;
            log "info" ,2:" rm_cfg_ram_data.RM_ENABLE = %x",$this.RM_ENABLE;
            log "info" ,2:" rm_cfg_ram_data.NETWORK_B_IC_ENABLE = %x",$this.NETWORK_B_IC_ENABLE;
            log "info" ,2:" rm_cfg_ram_data.NETWORK_A_IC_ENABLE = %x",$this.NETWORK_A_IC_ENABLE;
            log "info" ,2:" rm_cfg_ram_data.NETWORK_B_ENABLE = %x",$this.NETWORK_B_ENABLE;
            log "info" ,2:" rm_cfg_ram_data.NETWORK_A_ENABLE = %x",$this.NETWORK_A_ENABLE;
        }
    }
	
    register fragment_cfg_data 
    {
        //field RETENTION [31:11] is (zeros) "Reserved";
        field MAX_FRAME_LENGTH [10:0] "Max Frame Length";
		
        method after_write(memop) {
            log "info" ,2: "write fragment_cfg_data";
            log "info" ,2:"fragment_cfg_data.MAX_FRAME_LENGTH = %x",$this.MAX_FRAME_LENGTH;
        }
    }
    
    register tx_port_id      @ 0x3000 "Host send data frame Port ID register";
    register tx_frame_len    @ 0x3004 "Host send data frame length register";
    register tx_buf_overflow @ 0x3008 "Host send data frame overflow flag register";
    register tx_dst_ip_addr  @ 0x3040 "Host send data frame dest ip address";
    register tx_dst_udp_addr @ 0x3044 "Host send data frame dest udp address";
    
    register rx_port_id                   @ 0x3010 "To query the data frame port id";
    register rx_check_valid               @ 0x3014 "Determine whether there is a data frame receiving port";
    register rx_rec_frame                 @ 0x3018 "If write one, the device starts reading from the receive data frames Port cache";
    register rx_rec_state                 @ 0x301C "If one, the PCI bus can initiate DMA operation receiving current data frame";
    register rx_frame_len                 @ 0x3020 "Analyzing the received data frame";
    register rx_rec_network               @ 0x3024 "Determine the data to be received frome port A or B network";
    register rx_rec_time1                 @ 0x3028 "Analyzing received data frame time";
    register rx_rec_time2                 @ 0x3034 "Analyzing received data frame time";
    register rx_src_ip_addr               @ 0x3050 "Analyzing the data to be received source IP address";
    register rx_src_udp_addr              @ 0x3054 "Analyzing the data to be received source UDP address";
    register rx_sampling_port_freshness   @ 0x302C "Analyzing the sample port to receive data frames freshness";
    register rec_frame_drop               @ 0x3030 "Clear the current data frame";
    
	
    /////////////////////////// MIB begin ////////////////////////
    register tx_buf_overflow_port_id @0x6000;
    register tx_buf_overflow_num     @0x6004;
    register rx_buf_overflow_port_id @0x6008;
    register rx_buf_overflow_num     @0x600c;
    register MACA_MIB_addr           @0x6010;
    register MACA_MIB_data           @0x6014;
    register MACB_MIB_addr           @0x6018;
    register MACB_MIB_data           @0x601c;
    register rx_MIB_addr             @0x6020;
    register rx_MIB_data             @0x6024;
    register tx_MIB_addr             @0x6028;
    register tx_MIB_data             @0x602c;
    register mibs_clear              @0x7000;
    /////////////////////////// MIB begin ////////////////////////

    register tx_buf_overflow_num {
        method read() -> (value) {
            value = $tx_buf_overflow_number[$tx_buf_overflow_port_id];
        }
    }
    
    register rx_buf_overflow_num {
        method read() -> (value) {
            value = $rx_buf_overflow_number[$rx_buf_overflow_port_id];

        }
    }
    register mibs_clear {
        field res [31:4] is (reserved);
        field maca_clear [3:3] "maca clear bit";
        field macb_clear [2:2] "macb clear bit";
        field recv_mibs_clear [1:1] "recv mibs clear bit";
        field send_mibs_clear [0:0] "send mibs clear bit";
        
        method after_write(memop) {
            if($this.maca_clear == 1) {
                call $Clear_Maca_Mib_Info();
            }
            
            if($this.macb_clear == 1) {
                call $Clear_Macb_Mib_Info();
            }

            if($this.recv_mibs_clear == 1) {
                call $Clear_Rx_Mib_Info();
            }

            if($this.send_mibs_clear == 1) {
                call $Clear_Tx_Mib_Info();
            }
        }
    }

    register MACA_MIB_addr {
        method after_write(memop) {
            call $Recv_Mac_Mib_From_664_Middleware(MACA_MIB_CONFIG);
            
            switch($this) {
            case 0:
                $MACA_MIB_data = $maca_mib.crc_error;
                break;
            case 1:
                $MACA_MIB_data = $maca_mib.delete_little_64;
                break;
            case 2:
                $MACA_MIB_data = $maca_mib.delete_big_1518;
                break;
            case 3:
                $MACA_MIB_data = $maca_mib.input_frame_count;
                break;
            case 4:
                $MACA_MIB_data = $maca_mib.input_64_127_count;
                break;
            case 5:
                $MACA_MIB_data = $maca_mib.input_128_255_count;
                break;
            case 6:
                $MACA_MIB_data = $maca_mib.input_256_511_count;
                break;
            case 7:
                $MACA_MIB_data = $maca_mib.input_512_1023_count;
                break;
            case 8:
                $MACA_MIB_data = $maca_mib.input_1024_1518_count;
                break;
            case 9:
                $MACA_MIB_data = $maca_mib.input_frame_byte_count;
                break;
            case 10:
                $MACA_MIB_data = $maca_mib.output_frame_count;
                break;
            case 11:
                $MACA_MIB_data = $maca_mib.output_64_127_count;
                break;
            case 12:
                $MACA_MIB_data = $maca_mib.output_128_255_count;
                break;
            case 13:
                $MACA_MIB_data = $maca_mib.output_256_511_count;
                break;
            case 14:
                $MACA_MIB_data = $maca_mib.output_512_1023_count;
                break;
            case 15:
                $MACA_MIB_data = $maca_mib.output_1024_1518_count;
                break;
            case 16:
                $MACA_MIB_data = $maca_mib.output_frame_byte_count;
                break;
            case 17:
                $MACA_MIB_data = $maca_mib.first_bit_error_count;
                break;
            case 18:
                $MACA_MIB_data = $maca_mib.ipchecksum_error_count;
                break;
            case 19:
                $MACA_MIB_data = $maca_mib.delete_bit_2048_count;
                break;
            }
        }
    }

    register MACB_MIB_addr {
        method after_write(memop) {
            call $Recv_Mac_Mib_From_664_Middleware(MACB_MIB_CONFIG);
            
            switch($this) {
            case 0:
                $MACB_MIB_data = $macb_mib.crc_error;
                break;
            case 1:
                $MACB_MIB_data = $macb_mib.delete_little_64;
                break;
            case 2:
                $MACB_MIB_data = $macb_mib.delete_big_1518;
                break;
            case 3:
                $MACB_MIB_data = $macb_mib.input_frame_count;
                break;
            case 4:
                $MACB_MIB_data = $macb_mib.input_64_127_count;
                break;
            case 5:
                $MACB_MIB_data = $macb_mib.input_128_255_count;
                break;
            case 6:
                $MACB_MIB_data = $macb_mib.input_256_511_count;
                break;
            case 7:
                $MACB_MIB_data = $macb_mib.input_512_1023_count;
                break;
            case 8:
                $MACB_MIB_data = $macb_mib.input_1024_1518_count;
                break;
            case 9:
                $MACB_MIB_data = $macb_mib.input_frame_byte_count;
                break;
            case 10:
                $MACB_MIB_data = $macb_mib.output_frame_count;
                break;
            case 11:
                $MACB_MIB_data = $macb_mib.output_64_127_count;
                break;
            case 12:
                $MACB_MIB_data = $macb_mib.output_128_255_count;
                break;
            case 13:
                $MACB_MIB_data = $macb_mib.output_256_511_count;
                break;
            case 14:
                $MACB_MIB_data = $macb_mib.output_512_1023_count;
                break;
            case 15:
                $MACB_MIB_data = $macb_mib.output_1024_1518_count;
                break;
            case 16:
                $MACB_MIB_data = $macb_mib.output_frame_byte_count;
                break;
            case 17:
                $MACB_MIB_data = $macb_mib.first_bit_error_count;
                break;
            case 18:
                $MACB_MIB_data = $macb_mib.ipchecksum_error_count;
                break;
            case 19:
                $MACB_MIB_data = $macb_mib.delete_bit_2048_count;
                break;
            }
        }
    }

    register rx_MIB_addr {
        method after_write(memop) {
            call $Recv_Rx_Mib_Info_From_664_Middleware();
            switch($this) {
            case 0:
                $rx_MIB_data = $rx_mib.disable_A_filt_count;
                break;
            case 1:
                $rx_MIB_data = $rx_mib.disable_B_filt_count;
                break;
            case 2:
                $rx_MIB_data = $rx_mib.A_integrated_filt_count;
                break;
            case 3:
                $rx_MIB_data= $rx_mib.B_integrated_filt_count;
                break;
            case 4:
                $rx_MIB_data= $rx_mib.vl_id_filt_count;
                break;
            case 5:
                $rx_MIB_data =$rx_mib.redunt_filt_count ;
                break;
            case 6:
                $rx_MIB_data = $rx_mib.port_filt_count;
                break;
            case 7:
                $rx_MIB_data = $rx_mib.ip_checksum_filt_count;
                break;
            case 8:
                $rx_MIB_data = $rx_mib.ip_length_error_filt_count;
                break;
            case 9:
                $rx_MIB_data = $rx_mib.udp_length_error_filt_count;
                break;
            case 10:
                $rx_MIB_data = $rx_mib.ip_fragment_error_filt_count;
                break;
            case 11:
                $rx_MIB_data = $rx_mib.overflow_count;
                break;
            case 12:
                $rx_MIB_data = $rx_mib.rx_icmp_reback_count;
                break;
            case 13:
                $rx_MIB_data = $rx_mib.rx_ip_data_count;
                break;
            case 14:
                $rx_MIB_data = $rx_mib.rx_udp_data_count;
                break;
            case 15:
                $rx_MIB_data = $rx_mib.rx_icmp_data_count;
                break;
            case 16:
                $rx_MIB_data = $rx_mib.icmp_overflow_count;
                break;
            case 17:
                $rx_MIB_data = $rx_mib.rx_icmp_big_max_count;
                break;
            case 18:
                $rx_MIB_data = $rx_mib.rx_buffer_clear_delete_count;
                break;
            }
			
        }
    }

    register tx_MIB_addr {
        method after_write(memop) {
            call $Recv_Tx_Mib_Info_From_664_Middleware();
            switch($this) {
            case 0:
                $tx_MIB_data = $tx_mib.tx_ip_count;
                break;
            case 1:
                $tx_MIB_data = $tx_mib.tx_udp_count;
                break;
            case 2:
                $tx_MIB_data = $tx_mib.tx_icmp_count;
                break;
            }
        }
    }
    
    register analyse_cfg_cam_addr {
        method after_write(memop) {
            if (!$is_cfg_done) {
                call $write_analyse_cam();
            }
        }
        
        method write_analyse_cam() {
            $analyse_cfg_cam_array[$analyse_cfg_cam_index].
                cam_data_part1.ICMP_TYPE_ID = $analyse_cfg_cam_data3.ICMP_TYPE_ID;
            $analyse_cfg_cam_array[$analyse_cfg_cam_index].
                cam_data_part1.MULTICAST_ID = $analyse_cfg_cam_data3.MULTICAST_ID;
            $analyse_cfg_cam_array[$analyse_cfg_cam_index].
                cam_data_part2 = $analyse_cfg_cam_data2;
            $analyse_cfg_cam_array[$analyse_cfg_cam_index].
                cam_data_part3 = $analyse_cfg_cam_data1;
            $analyse_cfg_cam_array[$analyse_cfg_cam_index].address = $this;

            $analyse_cfg_cam_index++;
            
            if ($analyse_cfg_cam_index == ANALYSE_CFG_CAM_MAX_SIZE) { 
                $analyse_cfg_cam_index = 0;
            }
        } 
    }
    
    register analyse_cfg_ram_addr {
        method after_write(memop) {
            if (!$is_cfg_done) {
                call $write_analyse_ram();
            }
        }
        
        method write_analyse_ram() {
            $analyse_cfg_ram_array[$this].ram_data.
                NETWORK_B_ENABLE = $analyse_cfg_ram_data.NETWORK_B_ENABLE;
            $analyse_cfg_ram_array[$this].ram_data.
                NETWORK_A_ENABLE = $analyse_cfg_ram_data.NETWORK_A_ENABLE;
            $analyse_cfg_ram_array[$this].ram_data.
                PORT_TYPE = $analyse_cfg_ram_data.PORT_TYPE;    
        }
    }
    
    register transmit_cfg_ram_addr {  
        method after_write(memop) {
            if (!$is_cfg_done) {
                call $write_transmit_ram();
            }
        }
        
        method write_transmit_ram() {
            $transmit_cfg_ram_array[$this].ram_data_part1.
                PORT_TYPE = $transmit_cfg_ram_data4.PORT_TYPE;
            $transmit_cfg_ram_array[$this].ram_data_part1.
                MIN_FRAME_LENGTH = ($transmit_cfg_ram_data3.MIN_FRAME_LENGTH_PART1 ) |      
                ($transmit_cfg_ram_data4.MIN_FRAME_LENGTH_PART2<< 5);
            $transmit_cfg_ram_array[$this].ram_data_part1.
                IP_MULTICAST = $transmit_cfg_ram_data3.IP_MULTICAST;
            $transmit_cfg_ram_array[$this].ram_data_part1.
                VL_INDEX = $transmit_cfg_ram_data3.VL_INDEX;
            $transmit_cfg_ram_array[$this].ram_data_part1.
                VL_ID = $transmit_cfg_ram_data3.VL_ID;
            $transmit_cfg_ram_array[$this].ram_data_part2.
                USER_DEFINED_ID = ($transmit_cfg_ram_data2.USER_DEFINED_ID_PART1) |        
                $transmit_cfg_ram_data3.USER_DEFINED_ID_PART2<<14;
            $transmit_cfg_ram_array[$this].ram_data_part2.
                PROTOCAL_ID = $transmit_cfg_ram_data2.PROTOCAL_ID;
            $transmit_cfg_ram_array[$this].ram_data_part2.
                INTERFACE_ID = $transmit_cfg_ram_data2.INTERFACE_ID;
            $transmit_cfg_ram_array[$this].ram_data_part2.
                PARTITION_ID = $transmit_cfg_ram_data2.PARTITION_ID;
            $transmit_cfg_ram_array[$this].ram_data_part3.
                SOURCE_UDP_PORT = ($transmit_cfg_ram_data1.SOURCE_UDP_PORT_PART1 ) |         
                $transmit_cfg_ram_data2.SOURCE_UDP_PORT_PART2<<14;
            $transmit_cfg_ram_array[$this].ram_data_part3.
                DEST_UDP_PORT = $transmit_cfg_ram_data1.DEST_UDP_PORT;
            $transmit_cfg_ram_array[$this].ram_data_part3.
                SUB_VL_ID = $transmit_cfg_ram_data1.SUB_VL_ID;
            $transmit_cfg_ram_array[$this].ram_data_part4.
                USER_DEFINED_ID_H = $transmit_cfg_ram_data5.USER_DEFINED_ID_H;
            $transmit_cfg_ram_array[$this].ram_data_part4.
                USER_DEFINED_ID_L = $transmit_cfg_ram_data4.USER_DEFINED_ID_L;
            $transmit_cfg_ram_array[$this].ram_data_part4.
                PARTITION_ID = 	$transmit_cfg_ram_data4.PARTITION_ID;		
					
            $vl[$transmit_cfg_ram_data3.VL_INDEX].valid_id |= (1 << $transmit_cfg_ram_data1.SUB_VL_ID);
            $transmit_cfg_ram_index++;
        }
    }

    register scheduling_cfg_addr {
        method after_write(memop) {
            if (!$is_cfg_done)  {
                call $write_scheduling_ram();                
            }
        }

        method write_scheduling_ram() {
            $scheduling_cfg_ram_array[$this].BAG = $scheduling_cfg_data.BAG;
            $scheduling_cfg_ram_index++;
        }
    }

    register rm_cfg_cam_addr {
        method after_write(memop) {
            if (!$is_cfg_done) {
                call $write_rm_cam();
            }
        }

        method write_rm_cam() {
            $rm_cfg_cam_array[$rm_cfg_cam_index].VL_ID = $rm_cfg_cam_data.VL_ID;
            $rm_cfg_cam_index++;
        }
    }

    register rm_cfg_ram_addr {
        method after_write(memop) {
            if (!$is_cfg_done) {
                call $write_rm_ram();                
            }
        }
        
        method write_rm_ram() {
            $rm_cfg_ram_array[$this].ram_data.
                VL_ENABLE =  $rm_cfg_ram_data.VL_ENABLE;
            $rm_cfg_ram_array[$this].ram_data.
                SKEW_MAX = $rm_cfg_ram_data.SKEW_MAX;
            $rm_cfg_ram_array[$this].ram_data.
                RM_ENABLE = $rm_cfg_ram_data.RM_ENABLE;
            $rm_cfg_ram_array[$this].ram_data.
                NETWORK_B_IC_ENABLE = $rm_cfg_ram_data.NETWORK_B_IC_ENABLE;
            $rm_cfg_ram_array[$this].ram_data.
                NETWORK_A_IC_ENABLE = $rm_cfg_ram_data.NETWORK_A_IC_ENABLE;
            $rm_cfg_ram_array[$this].ram_data.
                NETWORK_B_ENABLE = $rm_cfg_ram_data.NETWORK_B_ENABLE;
            $rm_cfg_ram_array[$this].ram_data.
                NETWORK_A_ENABLE = $rm_cfg_ram_data.NETWORK_A_ENABLE;
            $rm_cfg_ram_index++;
        }
    }

    register fragment_cfg_addr {
        method after_write(memop) {
            if (!$is_cfg_done) {
                call $write_fragment_ram();                
            }
        }

        method write_fragment_ram() {
            $fragment_cfg_ram_array[$this].
                MAX_FRAME_LENGTH = $fragment_cfg_data.MAX_FRAME_LENGTH;
            $fragment_cfg_ram_index++;
        }
    }
    
    register icmp_serv_cfg_addr {
        method after_write(memop) {
			
        }
    }
    register tx_port_id {    
        field id [9:0] "Port ID";
    }    
	
    register tx_frame_len {
        field frame_len [17:0] "Send frame length";
    }

    register tx_dst_udp_addr {
        field dst_udp_addr [15:0] "Dest UDP address";
    }
	
    register tx_buf_overflow {
        field del_frame_id_valid_bit [1:1] "Deleting data frame identifier valid bit";
        field del_frame_id_bit [0:0] "Deleting data frame ID";
		
        method after_read(memop) {
            $this.del_frame_id_valid_bit = 0;
        }
    }
    
    register rx_check_valid {
        method read() -> (value) {
            local uint32 port_id = $pciport.rx_port_id;
            local bool is_empty;

            if (port_id >= 0 && port_id < 4096) {
                switch ($port[port_id].port_type) {
                case 0: case 1:
                    if ($middleware_mode == To429Middleware) {
                        inline $IsPortQueueEmpty($port[port_id].queue) ->(is_empty);
                    } else if ($middleware_mode == To664Middleware) {
                        inline $IsPortCacheEmpty($PortCache[port_id]) ->(is_empty);
                    } else {
                        log "info" : "Unsupported work mode!\n";
                    }
                    break;
                case 2:
                    inline $IsPortSampleEmpty(&($port[port_id])) -> (is_empty);
                    break;
                default:
                    log "error" : "Unsuported port type";
                    break;
                }
            } else {
                log "error": "wrong port id";
            }			
			
            if (is_empty) {
                value = 0;
            } else {
                value = 1;
            }
        }
        
    }
	
    register rx_rec_frame {
        method after_write(memop) {
            if ($this == 1) {			 
                local uint32 port_id = $pciport.rx_port_id;
                local bool is_empty;
                local PortItem item;
                local Cache_Item item1;
                if (port_id >= 0 && port_id < 4096) {
                    switch ($middleware_mode) {
                    case To429Middleware:
                        inline $DePortQueue($port[port_id].queue, &item)-> (is_empty);
                        if (is_empty == false) {
                            return;
                        }                                               
                        break;
                    case To664Middleware:
                        inline $DePortCache($PortCache[port_id], &item1) -> (is_empty);
                        if (is_empty == false) {
                            return;
                        }                                               
                        break;
                    default:
                        log "info" : "Unsupported work mode!\n";
                        break;                        
                    }
                } else {
                    log "error": "wrong port id";
                    return;
                }
				
                local exception_type_t ex;
                if ($middleware_mode == To429Middleware) {
                    item.size -= 8;
                    
                    call $pci_data_to_memory(Sim_Addr_Space_Memory,
                                             &item.frame[8],
                                             $pci9056.dmapadr0.padr0,
                                             item.size) -> (ex);
                    $pciport.rx_frame_len = item.size;
                } else if ($middleware_mode == To664Middleware) {
                    call $pci_data_to_memory(Sim_Addr_Space_Memory,
                                             item1.buffer,
                                             $pci9056.dmapadr0.padr0,
                                             item1.size) -> (ex);
                    $pciport.rx_frame_len = item1.size;
                }

                if (ex != Sim_PE_No_Exception) {
                    throw;
                    log "error": "write data to memory fail";
                }
                
                $pciport.rx_rec_state = 1;
                $pci9056.recvdmadone = 1;
            }
        }
    }
	
    register rx_rec_network {
        field rxdn [1:0] "receive data frame network" {
            method read() -> (value) {
                if (value == 1)
                    log "info",4,0: "data frame from network A";
                else if (value == 2)
                    log "info",4,0: "data frame from network B";
                else if (value == 3)
        
                    log "info",4,0: "data frame from both network A and network B";
            }
        }
        field res [31:2] is (reserved);
    }	
	
    register rx_rec_time1 {
        field us [9:0] "us";
        field ms [19:10] "ms";
        field s [25:20] "s";
        field min [31:26] "min";
    }
	
    register rx_rec_time2 {
        field h [4:0] "hour";
        field day [13:5] "day";
        field res [31:14] is (reserved);
    }
	
    register rx_sampling_port_freshness {
        parameter hard_reset_value = 0x1;
    }
}

